#!/usr/bin/env python

import argparse
import snakemake
import json 
import os
import sys 
import subprocess
from Bio import SeqIO

def main():
    parser = argparse.ArgumentParser(description='TESTING')
    parser.add_argument('--input', metavar='input_directory', type=str,
        help='Input directory of muscle alignments or consensus fasta sequences.')
    parser.add_argument('--output_dir', metavar='output_directory', type=str,
        help='Destination dir for SPEAR annotated VCFs')
    parser.add_argument('--data_dir', metavar='data_directory', type = str, 
        help ='Data files for peptide subpositions')
    parser.add_argument('--exclude_ambiguous', default=False, action='store_true',
        help = "Toggle whether to mask ambiguous bases in SNPs")
    parser.add_argument('--extension', metavar = '', type = str,
        help = "Suffix and extension for input files")
    parser.add_argument('--remove_inserted_N', metavar = '', type = str,
        help = "Suffix and extension for input files")
    parser.add_argument('--align', default=False, action='store_true',
        help = "Specify whether input fasta files should be aligned to NC_045512.2 reference genome using muscle.")
    parser.add_argument('--vcf', default=False, action='store_true',
        help = "Enter pipeline with VCF files in directory")
    parser.add_argument('--cutoff', metavar = '', type = int , default=50,
        help = "Percentage N cutoff for input sequences. Default 50")
    parser.add_argument('--split_vcfs', default=False, action='store_true',
        help = "Toggle per sample VCF file output")
    parser.add_argument('--threads' , metavar='', type = int, default = 1,
        help = "Max number of threads for snakemake job execution.")
    parser.add_argument('--deletion_window' , metavar='', type = int, default = 2,
        help = "Maximum number of flanking N's around deletion, default 2")
    parser.add_argument('--mask_problem_sites', metavar = 'SE AB AM HA HH HO IC NA NS NL SS AD BR all', nargs='+', 
        help = "Filter problematic sides with these codes")
    args = parser.parse_args()

    #need to write a problemsites vcf retrieval, gzip and tabix indexing script to run on install.
    if args.extension == None:
        if args.align:
            extension = ".consensus.fa"
        elif args.vcf:
            extension = ".vcf"
        else:
            extension = ".muscle.aln"
    else:
        extension = args.extension
    snakefile = "spear.smk"
    #setting the sample list for input to snakemake. Filtering based on N percentage and ensuring inputs have correct number of sequences.
    if args.align:
        input_samples = [(f.split('.'))[0] for f in os.listdir(args.input) if f.endswith(extension)] #HERE 
        passing_samples = []
        samples_fail_perc_n = 0
        samples_fail_count = 0
        for sample in input_samples:
            count = 0
            for record in SeqIO.parse(f'{args.input}/{sample}{extension}', "fasta"):
                count +=1
                if len(record.seq) == 0:
                    perc_n = 100
                else:
                    perc_n = (record.seq.count("N")/len(record.seq)) * 100 #factor indels in this count ? 
            if count > 1:
                samples_fail_count += 1
            elif perc_n >= args.cutoff:
                samples_fail_perc_n += 1   
            else:
                passing_samples.append(sample)
    elif args.vcf:
        passing_samples = [(f.split('.'))[0] for f in os.listdir(args.input) if f.endswith(extension)]               
    else:
        input_samples = [(f.split('.'))[0] for f in os.listdir(args.input) if f.endswith(extension)]
        passing_samples = []
        samples_fail_perc_n = 0
        samples_fail_count = 0
        for sample in input_samples:
            count = 0
            for record in SeqIO.parse(f'{args.input}/{sample}{extension}', "fasta"):
                count +=1
                if record.id == "NC_045512.2":
                    continue
                elif len(record.seq) == 0:
                    perc_n = 100
                else:
                    perc_n = (record.seq.count("N")/len(record.seq)) * 100
            if count != 2:
                samples_fail_count += 1
            elif perc_n >= args.cutoff:
                samples_fail_perc_n += 1
            else:
                passing_samples.append(sample)
    if args.vcf:
        print(f'''
        Input samples : {len(passing_samples)}
        ''')
    else:
        print(f'''
        Input samples : {len(input_samples)}
        Passing samples : {len(passing_samples)}
        %N > {args.cutoff} : {samples_fail_perc_n}
        Incorrect format : {samples_fail_count}
        ''')
    if args.exclude_ambiguous:
        exclude = "-ambiguousToN"
    else:
        exclude = ""
    problem_sites = args.mask_problem_sites

    problem_exc = {
        "SE" : "seq_end", 
        "AB" : "ambiguous", 
        "AM" : "amended",
        "HA": "highly_ambiguous", 
        "HH" : "highly_homoplasic", 
        "HO" : "homoplasic", 
        "IC" : "interspecific_contamination", 
        "NA" : "nanopore_adapter", 
        "NS": "narrow_src", 
        "NL": "neighbour_linked" , 
        "SS": "single_src", 
        "AD": "amplicon_drop_or_primer_artefact", 
        "BR": "back_to_ref"}

    exclusion_statements = []
    if problem_sites == None:
        filter_snps = False
        filter_statement = ""
    else:
        filter_snps = True
        if "all" in problem_sites:
            filter_statement = f"problem_filter = 'mask'"
        else:
            for site in problem_sites:
                try:
                    problem_exc[site]
                    statement = f" problem_exc =~ '{problem_exc[site]}' "
                    exclusion_statements.append(statement)

                except KeyError:
                    print("Masking parameter not recognised")
                    parser.print_help()
                    sys.exit(1)
            exclusions = "|".join(exclusion_statements)
            filter_statement = f"problem_filter = 'mask' & ({exclusions})"
    
    config = {
        "input_dir" : args.input,
        "samples" : passing_samples, 
        "output_dir" : args.output_dir,
        "data" : args.data_dir,
        "align" : args.align,
        "fatovcf": "/Users/matthewcrown/Desktop/fatovcf", #needs to be in path
        "exclude_ambiguous" : exclude,
        "get_indels": "/Users/matthewcrown/GitHub/SPEAR/get_indels.py", #needs to be in path
        "reference_sequence" : f'{args.data_dir}/SARS-CoV-2.reference.fasta', #could be in path
        "filter" : filter_snps,
        "filter_params" : filter_statement,
        "split_vcfs": args.split_vcfs,
        "del_window" : args.deletion_window,
        "extension" : extension,
        "vcf" : args.vcf}

    status = snakemake.snakemake(
                snakefile, 
                printshellcmds=False,
                config=config, 
                quiet=False, 
                forceall = False, 
                printdag = False, 
                cores = args.threads)

    if status:
       return 0
    return 1


if __name__ == "__main__":
    main()